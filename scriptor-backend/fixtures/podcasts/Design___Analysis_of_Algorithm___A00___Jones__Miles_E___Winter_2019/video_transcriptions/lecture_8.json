{
    "Blurbs": {
        "Heap at random, right because they all start with infinity as their key value. Okay, but let's suppose you're using the heat for something else and you want to make a heap out of a bunch of objects that all have kind of random key values and they don't come come to you in any particular order. Okay. So how long do you expect it to take to make a ": [
            211.1,
            240.1,
            3
        ],
        "High class seems like I'm having some technical problems. So just give me a second. I'm going to turn it off and then turn it back on again. Tends to happen sometimes in this room. Anybody have any questions before we begin? It looks like it's working good. I threw it like that. Okay, great. alright, so last time we we took the time to Talk about dijkstra's algorithm in ": [
            73.1,
            152.2,
            0
        ],
        "Okay, so quit what happened to my other thing again while just write it? Okay. So this is contingent on the fact that this is equal to n x J equals one up to login Jay over to the Jay Frank you could factor out that end and now this here. Is actually a convergent sum. so this is J equals one up to Infinity I or J over 2 ": [
            1087.2,
            1128.9,
            27
        ],
        "Okay, so why would you want to do this think about an example where you have like a bunch of computer networks or computers a network of computers that are linked pairwise and each link has some sort of operational maintenance cost. So you want all the computers to stay connected but you want to take get rid of the car that some of the links so that you can ": [
            1320.7,
            1346.1,
            33
        ],
        "Okay. We going to save any time by doing this. I think we should kind of see what happens, right? Okay, so let's suppose we have all these vertices and these are just objects with their keys and notice. They're not in any particular order right there just kind of scrambled and and this problem is to have a you know, an unordered list, right? Cuz if the list were ": [
            655.3,
            683.9,
            14
        ],
        "Vertex? It's only when another vertex is put into X so you can start seeing the the similarities between this and dijkstra's algorithm. so let's think about it an in kind of use this cost to make our decisions now initialize all the cost put the whatever vertex in X and then update the cost of all of its neighbors. then put the lowest cost in 2X and update all ": [
            2588.3,
            2619.9,
            61
        ],
        "Where insert takes login in the number of levels? Kelley Blue Book actually, let me do something real fast. even though it's supposed to be less than Is that not working anymore? Crap, what do I do? Okay good. Okay, so what do you guys say? And login, how did you get that? Okay. Okay good. So it certainly will take Big O of n log in right? Because maximum ": [
            338.8,
            443.1,
            7
        ],
        "Yeah. Okay, any questions about that? Okay, good. So straightforward you understand how it works, right? I have that again. Okay, that's fine. All right, let's try to go from high-level to a mid-level. So This is the high-level algorithm that I just presented to you. What we need to do is figure out how to do these operations. I mean, I did it right before your eyes, but I ": [
            1900.8,
            1932.8,
            46
        ],
        "a few minutes to talk it over with your neighbor just figure out which edges do I need to make a minimum spanning tree? Let's go with this first. What is the cost? of the minimum spanning tree All right. So, what did you guys get for the cost? 12 anybody can do better than that. Can I see how we can get 12? I think if we do these ": [
            1581.8,
            1676.8,
            38
        ],
        "about you? That sound good. Doesn't matter. so that read that red circle that will be X. Okay. So look at all the edges that cross the boundary of xor that start in X and end in you so which one has the lowest weight? Is this one 1/2 G, right? so Angie will be part of my output and now you put GNX. Okay. So now I now you ": [
            1782.1,
            1818.8,
            43
        ],
        "actually like generating money. It's tough to dies. Cuz then you're starting to lose my gas. So let's think I mean this problem actually. With or without negative edges we can we can still talk about the minimum spanning tree. So but let's think more of positive edges. I like that better or Cuz of zero edge of kind of like, well, it's sort of like not even there. So ": [
            1452.6,
            1487.3,
            36
        ],
        "all bigger than login / 2. And so you have an over two of those? I'll just I'll just leave this as an exercise for you guys. Guy and really exercise. I really want you guys to do is this part? I want you to do the Omega part, right? Because the Big O part is is easy to move on from that. That's fine. I'm sure we have something ": [
            558.7,
            602.9,
            11
        ],
        "an induction proof with it, or you can do it with an integral. He could show that the integral is is a finite value something like that. Any other questions? Okay. Good song Make The Chew. of an object's it takes us a text Big O of end time. For r44 are algorithm dijkstra's algorithm. It's going to doesn't really matter if it takes end timer and log in time ": [
            1166.5,
            1214.6,
            29
        ],
        "and over again. So let's look at it like more like a pseudocode or implementation level. function to do this Okay, how long do you expect this function to make two how long do you expect this function to run? If it takes to make a binary heat from an object each with a key value. Do you start with your first two objects? Put it in the Heap and ": [
            272.3,
            305.4,
            5
        ],
        "because the whole algorithm takes more than n log in time anyway, but I don't know. Maybe you need this in a different if a different for different purpose, right? It's a nice way to organize data. And it makes for finding you know, the the lowest value really easy. Okay, let's move on to another problem minimum spanning trees. Okay. What is a minimum spanning tree? Will first let's ": [
            1214.6,
            1245.4,
            30
        ],
        "binary heat from an object each with a key value? Well when we talked about this operation insert, but if you think about inserting an inserting a node You can kind of place it at the very last position and let it bubble up right and then that will be some way to put it in. So one idea for creating a a heap. is 2 Use this insertion over ": [
            240.1,
            272.3,
            4
        ],
        "case. You just put them in and you're done. So the next step is to put is to fill in these for gaps right with these next four vertices. Now at this point you might have some vertices that are sort of in the wrong position. So let them trickle down into their right positions. So notice how OMD are in the they're in the wrong. Position so swap them ": [
            710.5,
            743.1,
            16
        ],
        "define. What is a spanning tree spanning tree is a subgraph of a connected undirected graph. They so we're moving into kind of chapter 5 5.1. We talked about minimum spanning trees and whenever I say Graff I'm always thinking of an undirected. I should say connected. connected graph Okay, so I spanning tree is just a subgraph that's a tree and all of the vertices are in the graph ": [
            1245.4,
            1284.1,
            31
        ],
        "detail. Right? We proved its correctness it and talks about how to implement. It talks about a sort of a mid-level description where we could we could sort of put different implementations in there to get different run times. And and so today we're going to look a little bit more into the priority queue and what you can do with it and what type of features that has and ": [
            152.2,
            181.7,
            1
        ],
        "did was change in a few letters and things like that. We didn't really change the run time. So this shares the same run time as dijkstra's one big difference here is that prims only allows for connected graphs to ever be a input and so all connected graphs have is Big Omega of V. Because that very worst you have a tree and you have B -1 edges. So ": [
            2733.6,
            2765.0,
            65
        ],
        "do a priority queue with edges. Let's say we do with you they keep right then every time you do every time you pick a minimum value. if to do log e many operations So how long would that run? Analog E. I guess which is pretty good. Okay. Maybe it's just I'm thinking about a different way to do it. But any other okay. Well, yeah, if you're if ": [
            2339.9,
            2392.3,
            54
        ],
        "do it efficiently. But let's just think about how do I first do this? Well, my first instinct would say, okay. What I'm going to do is keep the Boolean array 4X right. So it's basically the visited array right? And so then I'm going to go through all my edges and check to see if one if each endpoint is in Acts and not an ex right then pick ": [
            2126.4,
            2162.6,
            49
        ],
        "edges into a priority queue. Okay, so that means that you can have this priority queue fill with edges and you can pick the lowest one each time. good song me just kind of give another slide cuz actually wasn't thinking about doing it that way, but that's great. Okay, so keep. a priority queue of edges Okay, so then you can use priority. Okay any other ideas? So we ": [
            2289.2,
            2339.9,
            53
        ],
        "edges of wait to sweep pick any of them. Let's pick this one to see sorry don't have an animation for this. AC and then we also have two edges that are weight to those are both going to be so let's pick. I don't know this one. Hey B. And now we can pick any of those edges cuz they're all the same weight. So let's pick this one. ": [
            1864.1,
            1899.8,
            45
        ],
        "edges, but keep track of the endpoints of those edges cuz those are the things that really matter right? Those are the things. I'm going to be putting into my ex. Okay. So now we're going to have this cost value for each vertex and we're going to pick the next vertex to put an X based on its cost and what is it cost cost is what is the ": [
            2419.8,
            2449.2,
            56
        ],
        "get it. Yeah. Sure. I don't know maybe even Monday you can come talk to me after class. Bring back the Cookie Monster example for the greedy. Did you like that? Alright, I'll do that. ": [
            2888.6,
            2905.1,
            69
        ],
        "guys here and the three in the fourth, right. Org. Okay, good. Algorithm you use you might have used let her know a certain type of algorithm to do this or you might have just kind of figured it out or played around with it. So we're going to look at two main algorithms to solve this problem. They're called prims and kruskal. We're going to look at Prince first, ": [
            1676.8,
            1701.4,
            39
        ],
        "into the zero, right? And so think about how far they fell in the first layer. They didn't fall it all the second layer. They fell one level the third layer they felt two levels or sorry. The Pearl are they felt nothing the second layer they fell won the first layer they fell to in the last layer. They the top layer they felt 3. Okay, so think about ": [
            893.8,
            918.3,
            21
        ],
        "is it connected graph not a tree is when? there Is a cycle? And then if you cut any of the cycle edges the grass stays connected. connected Frank chopp just cut any of those cycle edges and your cost will go down. Is that assuming everything? assuming Edge weights are non negative What would that mean in that computer network? That would mean that one of those networks is ": [
            1387.4,
            1452.6,
            35
        ],
        "it doesn't matter if it's like I says your age would be better than any other Edge. But let's make a positive edges. Okay, wait, so why something happened here? I opened up the wrong thing. Did I? Hold on. Let me just see something here. So your ass. tube Okay good. And have the most updated version here or give me an example of a minimum spanning tree take ": [
            1487.3,
            1581.8,
            37
        ],
        "it like this. Let's assume that and is equal to 2 to the K - 1 so it's just like this full tree, right and you can kind of think about it like that. So there are K - 1 levels. or actually K levels, but I wanted to say it like there are levels 02 K -1 you put in half of the vertices, right? or around half Paint ": [
            918.3,
            959.4,
            22
        ],
        "just pretend those are right because rap, okay. Okay. Now if I put it like this than their right? Right. Okay, then you're right so that a just had to go down one. And now you have the binary Heap. Okay, so noticed that the first level I put in two to the three vertices then I put into the two then I put into the one that I put ": [
            862.8,
            893.8,
            20
        ],
        "lightest Edge that's coming from X to that for a text? Okay, so let's just I just kind of added a few remarks to the other description so you can see where I changed it. so basically for all the vertices update the cost to be the weight of the lightest Edge connecting it to a vertex in X right find the minimum Edge this just translates to find the ": [
            2449.2,
            2480.9,
            57
        ],
        "look at all the edges that cross over the boundary of X meaning all the edges where one endpoint is in X, and the other endpoint is in you. And out of all of them pick the edge with the lowest weight and then put that put that endpoint in Acts and repeat. Let's look at how this would work. Which Edge do you guys want to start from? How ": [
            1755.1,
            1782.1,
            42
        ],
        "look at only the edges that are crossing over the boundary of X, which one is the lowest. There's two lowest you can pick either or so. Which one do you want to pick? about D Big D And now this is acts. So then we have DG. Okay, and then this one is the lowest right? So we have DEA. Put that in there. So now we have three ": [
            1818.8,
            1864.1,
            44
        ],
        "of its neighbors and then keep on doing that until everything is in x queso in Moore You can sort of see the similarities instead of using disc now. We're using cost and they're just they're both just a raise of numbers. You just update them differently. So we can use the exact same algorithm structure. Okay, so let's just go through this quickly. pick any random vortex do all ": [
            2619.9,
            2656.7,
            62
        ],
        "okay. So is this an login is this big Theta of n login? It's certainly big out right because you can bound every one of these things above by login, but is it big data? Do you have light one? 1.2%. At the end? It's still a great night, like Sure. Yeah, one way you can look at it is that So the the last half of this some are ": [
            511.8,
            558.7,
            10
        ],
        "okay. kruskal's kind of is more of the More obvious way to do it, but prim's algorithm. I wanted to present it now because you'll see it's a lot like what we've just been talking about. Okay, so prim's algorithm. What what do you want to do? You given a graph with positive Edge weights or it's just a positive Edge weights and your output is a list of edges ": [
            1701.4,
            1728.4,
            40
        ],
        "or all of the vertices are connected or the whole graph is connected. So for example, you can have something that looks like this this would be a spanning tree something like that the tree so So any output tree of DFS or BFS is a spanning tree also, right because it contains all the vertices and the output. Is this sort of DFS output tree or BFS output tree. ": [
            1284.1,
            1317.3,
            32
        ],
        "or let them trickle down to swap them see if it works out. Yeah. Okay great. So then you do that. Alright, which one else what other ones do you want to swap? Can ask go with the lower child? Cuz if you traded B, then B would be over at right and so then E-Trade with h. And then and then just leave it there. It's fine, right? execute ": [
            743.1,
            775.1,
            17
        ],
        "ordered you can just put them in in order and I'll be fine. So and that would take end time of course if they're just in some scrambled order. So the first thing to do is fill in the bottom layer, right? This tree has three layers. And so this is two to the three vertices, right? That makes sense to put them in and that's in that in that ": [
            683.9,
            710.5,
            15
        ],
        "put me into X and you update all of its neighbors. So be now becomes 2D becomes 3. FB comes for Angie becomes one then you look at the minimum vertex, right? Cuz that's going to be corresponding to the minimum Edge coming out which is G. And now update only the neighbors of G because those are the only ones that are going to change once you put that ": [
            2517.7,
            2549.4,
            59
        ],
        "put them in the opposite order? Would that help out? So here is a here's a way to make a heap. Let's fill in the bottom layer of the heat first. Okay, just randomly, then we'll fill in the next layer. And as we fill it in will update by letting those vertices trickle-down if they need to write and then build the next layer and build the next layer. ": [
            626.2,
            655.3,
            13
        ],
        "really the number in the worst-case you're going to do one log. Well that doesn't really make sense that start with to log to 2 log 2 + 3 log 3 fast for lock for all the way up to Plus nowait Nazis All the way up to log in this is what it is, right? so it's the song from I equals to up to n of log I ": [
            473.0,
            510.5,
            9
        ],
        "really this is around log base 2 of n * 10/2 to the log base 2 of n which is log base 2 of N and that makes sense because when you add in that last vertex, it might have to fall the entire length of a tree. Okay, so The whole runtime of this algorithm is the sum of all of these things, right? So we have this some ": [
            1010.9,
            1042.7,
            25
        ],
        "right and this is just what we what we said before. Okay. I claim that this sum is Big O of n Anybody believe me? Okay, so if it's all love and then you have a linear sorting algorithm. Okay, how would that work? Yeah, right just building the heat take big event. But if you wanted to like sort them with the heat, then it would take 10 login. ": [
            1042.7,
            1085.9,
            26
        ],
        "right? Because basically this means that every time you go through This Loop here. I need to Loop through all the edges and I'm going through this Loop V number of time, right? Because I'm trying to put every vertex into acts. So with this implementation you get a runtime of Big O of the x e That's a good first step. Anybody want to share their ideas on how ": [
            2227.6,
            2257.2,
            51
        ],
        "save money on the cost. You're going to try to find the minimum spanning tree of that Network right? It's going to be the minimum total cost where you can keep everything connected. Okay. So the first kind of thing we should think about is does this necessarily have to be a tree? Does the minimum cost connected graph have to be a tree? Psy Okay, good. So when when ": [
            1346.1,
            1387.4,
            34
        ],
        "so that means that with a binary Heap instead of B plus C Lavie now, it's just you lock me. Okay, and that backslash didn't compile this fine? And then the array is also vsquare so you get the same sort of thing. Okay, any questions about that? Nobody's curious about the correctness. You just trust that it works since it's in the book and has a fancy name. It'll ": [
            2765.0,
            2811.2,
            66
        ],
        "that describes the minimum spanning tree, right if I just give you the edges that's enough to reconstruct the tree. Okay, here's the idea and we're going to do it and sort of like a high-level with sets. So put all of the vertices in you. pick any random vertex and put it in x And then repeat this process until all vertices are in X in the process is ": [
            1728.4,
            1755.1,
            41
        ],
        "that. I thought it was all nice and works nicely, but it doesn't so. Okay, I'll fix it up in the slides and you guys can see it but you get the idea right questions. Alright, so then now it looks okay and then you just put the last vertex on and did I? Oh crap. Now, this is Ron still. Know what is it K12 Frank? Okay. Okay now ": [
            820.3,
            862.8,
            19
        ],
        "the bottom layer has around half of the vertices. Okay, and then the second pass you put in a quarter of the vertices, but you might have to do two operations pervert X you need to put it in and it might have to fall twice. Right and then the third pass you put in an eighth of the vertices, but you might have to do three operations you put ": [
            959.4,
            981.0,
            23
        ],
        "the idea All right. Next stage is to put the next two on there right and let those trickle-down. So change G with what? F and then Cherry G with what beer k Oh, I didn't do it yet. Shoot wait, I trade it with K. This is this is all messed up. All right. I'll just do it like this. Wait a minute. Ya B10 and G22. Sorry about ": [
            775.1,
            820.3,
            18
        ],
        "the initializations right? So the cost for infinity and all this stuff just like we did before. And this whole part here. Is just regular Graph Search like we did before except for we're picking vertices carefully and we're updating the cost and that cost is what we're going to use to pick the next protect. So it's the same thing we did with dijkstra's. Okay, and the way that ": [
            2656.7,
            2685.2,
            63
        ],
        "the minimum 1 and that'll be my next Edge right and then move the vertex in queso Loop through. all edges Check endpoints. and find minimum that looks a that crosses. boundary of x and then output that edge and then change Boolean of that important Facebook is great because this what does the job it's it's something that will the solve the problem but this is not super efficient, ": [
            2162.6,
            2227.6,
            50
        ],
        "the minimum edge with one vertex in X and one vertex in you? What are my father? Okay. So before anybody share their their idea, I want to present to you like a a first kind of. sort of not a Brute Force way, but kind of a direct way to do this cuz I'm sure some of you seen prims and maybe you have the idea of how to ": [
            1974.4,
            2126.4,
            48
        ],
        "them in and then each one may fall to levels, right? And so in general for the jpas you have to do J times and over to the jail operations. And in the top pass you have to do pay times and over to the K operations work a at the number of levels and another way to write K is it's a round log base 2 of n so ": [
            981.0,
            1010.9,
            24
        ],
        "then for each subsequent object you keep on putting it into the next available position and let it bubble up. and so this is like a Recursive function to do it, right? You're just basically inserting the big the other than the next element into the heat that you've already made himself. Take a minute to talk it over with your neighbor. How long do you expect this to take? ": [
            305.4,
            333.6,
            6
        ],
        "then we're going to look at another problem that you can use the priority queue to solve. Okay. So the first thing I want to revisit is the binary Heap And for this for dijkstra's algorithm, this is not super important because when we make the heat for dijkstra's algorithm, you can just put the starting vertex at the root and then you can put all other vertices in the ": [
            181.7,
            211.1,
            2
        ],
        "to keep on at the next Edge that will contribute the least amount to each thing. was that I posted today and I also posted some practice problems for the quiz. Yeah. Bank of America number 105 should come a different time. Are you free this afternoon or this evening? No, but next week I can do next week. Yeah, I would like some I would appreciate some! I totally ": [
            2838.0,
            2888.6,
            68
        ],
        "to make a keep in and log in time and and that's fine. Okay. Can we improve on this bound to improve on this run time? Okay. So what if we so in in this since we started kind of putting it put the first one at the root and then keep on putting them into the tree and building the tree one by one like that. What if we ": [
            602.9,
            626.2,
            12
        ],
        "to make it more efficient. From your ex the ones that are connected to the one being when you put something in X put all the edges and priority queue. Cuz that's when you moved from d2x whenever you do that to me for each of that vertex. Look at all that. priority queue Okay. So every time you move a vertex in two acts put all of its outgoing ": [
            2257.2,
            2289.2,
            52
        ],
        "to the J is actually equal to 2. GameStop, it's like one of these songs that the each summation each next term is small enough that it will convert to some number there for this whole song is got to be less than 2 and which is bigger event. Okay, so maybe you could do this as an exercise. Any questions about that? Take me to do it by there's ": [
            1128.9,
            1166.5,
            28
        ],
        "vertex in. So that's where we're going to get the better efficiency. Okay, and Saudi updates to 2. Bendy, the orbi is the lowest ones. Let's go a d so put D in there. and now we get to update a and so on. Okay, I'll let you guys. I have your imagination to how this story ends. Okay, how do we Implement Prince while when do we update a ": [
            2549.4,
            2588.3,
            60
        ],
        "vertex outside of X that has the lowest cost. And then once you move the edge into X update all the cost again, keep on going see how that works. queso I don't have a nice animation, but you can sort of see how it's going to work. Let's do the same starting place. Okay, so we start with Z 0 and all of these are Infinity, right? So you ": [
            2480.9,
            2517.7,
            58
        ],
        "was kind of implying or use common sense and intuition to kind of just figure it out. So with your neighbors discuss how you would Implement prim's algorithm. How would you do these things? And what are the things that I'm asking is well, How would you find this minimum Edge? I think that's big the biggest think how would you do that? Okay, ready go. How do we find ": [
            1932.8,
            1974.4,
            47
        ],
        "we update it is. If its cost is bigger than the weight of the edge that's coming out of the set X then update it to that way. Okay, and so then we can actually take dijkstra's algorithm and change only the name disc to cost and then the way that it updates and it's the same thing. Pretty cool. So let's look at the run time spent all we ": [
            2685.2,
            2733.6,
            64
        ],
        "work. Well luckily for you guys or maybe unluckily for you guys. You're going to have to wait till next week for the correctness proof. But before you guys go. Sorry. The next thing we're going to do is the greedy approach. So if you already know what it is then read up on it, and if you don't then think about what does that mean the greedy approach try ": [
            2811.2,
            2838.0,
            67
        ],
        "you're going to have to Bubble Up the entire length of the tree to get to the top in the worst-case really but this is just an upper bound, right cuz we're doing worst-case. What about a lower bound well, Let's think about what happens every time you put in a new element. It's going to be K latte with a number of elements that are already in there. So ": [
            443.1,
            473.0,
            8
        ],
        "you're talking about anything that like you're going to the date is going to be more useful to you in sorted order then usually you need like an analog anything but Okay, so let's let's go to towards what prims algorithm does. So instead of putting a priority queue of edges were going to actually use a priority queue of vertices. Okay, and so instead of keeping track of the ": [
            2392.3,
            2419.8,
            55
        ]
    },
    "File Name": "Design___Analysis_of_Algorithm___A00___Jones__Miles_E___Winter_2019-lecture_8.flac",
    "Full Transcript": "High class seems like I'm having some technical problems. So just give me a second. I'm going to turn it off and then turn it back on again.  Tends to happen sometimes in this room.  Anybody have any questions before we begin?  It looks like it's working good.  I threw it like that.  Okay, great.  alright, so  last time we we took the time to  Talk about dijkstra's algorithm in detail. Right? We proved its correctness it and talks about how to implement. It talks about a sort of a mid-level description where we could we could sort of put different implementations in there to get different run times. And and so today we're going to look a little bit more into the priority queue and what you can do with it and what type of features that has and then we're going to look at another problem that you can use the priority queue to solve. Okay. So the first thing I want to revisit is the binary Heap  And for this for dijkstra's algorithm, this is not super important because when we make the heat for dijkstra's algorithm, you can just put the starting vertex at the root and then you can put all other vertices in the Heap at random, right because they all start with infinity as their key value.  Okay, but let's suppose you're using the heat for something else and you want to make a heap out of a bunch of objects that all have kind of random key values and they don't come come to you in any particular order. Okay. So how long do you expect it to take to make a binary heat from an object each with a key value? Well when we talked about this operation insert, but if you think about inserting an inserting a node  You can kind of place it at the very last position and let it bubble up right and then that will be some way to put it in. So one idea for creating a a heap.  is 2  Use this insertion over and over again.  So let's look at it like more like a pseudocode or implementation level.  function to do this  Okay, how long do you expect this function to make two how long do you expect this function to run? If it takes to make a binary heat from an object each with a key value. Do you start with your first two objects? Put it in the Heap and then for each subsequent object you keep on putting it into the next available position and let it bubble up.  and so this is like a  Recursive function to do it, right? You're just basically inserting the big the other than the next element into the heat that you've already made himself. Take a minute to talk it over with your neighbor. How long do you expect this to take?  Where insert takes login in the number of levels?  Kelley Blue Book  actually, let me do something real fast.  even though it's supposed to be less than  Is that not working anymore?  Crap, what do I do?  Okay good.  Okay, so what do you guys say?  And login, how did you get that?  Okay.  Okay good. So it certainly will take Big O of n log in right?  Because maximum you're going to have to Bubble Up the entire length of the tree to get to the top in the worst-case really but this is just an upper bound, right cuz we're doing worst-case. What about a lower bound well,  Let's think about what happens every time you put in a new element. It's going to be K latte with a number of elements that are already in there. So really the number in the worst-case you're going to do one log.  Well that doesn't really make sense that start with to log to  2 log 2 + 3 log 3  fast for lock for  all the way up to Plus  nowait Nazis  All the way up to log in this is what it is, right?  so it's the song from I equals to up to n of log I  okay.  So is this an login is this big Theta of n login?  It's certainly big out right because you can bound every one of these things above by login, but is it big data?  Do you have light one? 1.2%. At the end? It's still a great night, like  Sure. Yeah, one way you can look at it is that  So the the last half of this some are all bigger than login / 2.  And so you have an over two of those?  I'll just I'll just leave this as an exercise for you guys.  Guy and really exercise. I really want you guys to do is this part?  I want you to do the Omega part, right?  Because the Big O part is is easy to move on from that. That's fine. I'm sure we have something to make a keep in and log in time and and that's fine. Okay.  Can we improve on this bound to improve on this run time? Okay. So what if we so in in this since we started kind of putting it put the first one at the root and then keep on putting them into the tree and building the tree one by one like that. What if we put them in the opposite order? Would that help out?  So here is a here's a way to make a heap. Let's fill in the bottom layer of the heat first. Okay, just randomly, then we'll fill in the next layer. And as we fill it in will update by letting those vertices trickle-down if they need to write and then build the next layer and build the next layer. Okay. We going to save any time by doing this.  I think we should kind of see what happens, right?  Okay, so let's suppose we have all these vertices and these are just objects with their keys and notice. They're not in any particular order right there just kind of scrambled and and this problem is to have a you know, an unordered list, right? Cuz if the list were ordered you can just put them in in order and I'll be fine. So and that would take end time of course if they're just in some scrambled order. So the first thing to do is fill in the bottom layer, right?  This tree has three layers. And so this is two to the three vertices, right?  That makes sense to put them in and that's in that in that case. You just put them in and you're done.  So the next step is to put is to fill in these for gaps right with these next four vertices.  Now at this point you might have some vertices that are sort of in the wrong position. So let them trickle down into their right positions. So notice how OMD are in the they're in the wrong.  Position so swap them or let them trickle down to swap them see if it works out. Yeah. Okay great. So then you do that. Alright, which one else what other ones do you want to swap?  Can ask go with the lower child? Cuz if you traded B, then B would be over at right and so then E-Trade with h.  And then and then just leave it there. It's fine, right?  execute the idea  All right. Next stage is to put the next two on there right and let those trickle-down. So change G with what?  F and then Cherry G with what beer k  Oh, I didn't do it yet.  Shoot wait, I trade it with K. This is  this is all messed up.  All right. I'll just do it like this.  Wait a minute. Ya B10 and G22.  Sorry about that.  I thought it was all nice and works nicely, but it doesn't so.  Okay, I'll fix it up in the slides and you guys can see it but you get the idea right questions.  Alright, so then now it looks okay and then you just put the last vertex on and did I?  Oh crap.  Now, this is Ron still.  Know what is it K12 Frank?  Okay.  Okay now just pretend those are right because rap, okay.  Okay. Now if I put it like this than their right?  Right. Okay, then you're right so that a just had to go down one. And now you have the binary Heap. Okay, so noticed that the first level I put in two to the three vertices then I put into the two then I put into the one that I put into the zero, right? And so think about how far they fell in the first layer. They didn't fall it all the second layer. They fell one level the third layer they felt two levels or sorry.  The Pearl are they felt nothing the second layer they fell won the first layer they fell to in the last layer. They the top layer they felt 3. Okay, so think about it like this.  Let's assume that and is equal to 2 to the K - 1 so it's just like this full tree, right and you can kind of think about it like that. So there are K - 1 levels.  or  actually K levels, but I wanted to say it like there are levels 02 K -1 you put in half of the vertices, right?  or around half  Paint the bottom layer has around half of the vertices. Okay, and then the second pass you put in a quarter of the vertices, but you might have to do two operations pervert X you need to put it in and it might have to fall twice. Right and then the third pass you put in an eighth of the vertices, but you might have to do three operations you put them in and then each one may fall to levels, right? And so in general for the jpas you have to do J times and over to the jail operations. And in the top pass you have to do pay times and over to the K operations work a at the number of levels and another way to write K is  it's a round log base 2 of n  so really  this is around log base 2 of n * 10/2 to the log base 2 of n  which is log base 2 of N and that makes sense because when you add in that last vertex, it might have to fall the entire length of a tree.  Okay, so  The whole runtime of this algorithm is the sum of all of these things, right?  So we have this some right and this is just what we what we said before. Okay. I claim that this sum is Big O of n  Anybody believe me?  Okay, so if it's all love and then you have a linear sorting algorithm. Okay, how would that work?  Yeah, right just building the heat take big event. But if you wanted to like sort them with the heat, then it would take 10 login.  Okay, so  quit what happened to my other thing again while just write it? Okay. So this is contingent on the fact that this is equal to n x  J equals one up to login  Jay over to the Jay Frank you could factor out that end and now this here.  Is actually a convergent sum.  so this is  J equals one up to Infinity I or J over 2 to the J is actually equal to 2.  GameStop, it's like one of these songs that the each summation each next term is small enough that it will convert to some number there for this whole song is got to be less than 2 and which is bigger event.  Okay, so maybe you could do this as an exercise.  Any questions about that?  Take me to do it by there's an induction proof with it, or you can do it with an integral. He could show that the integral is is a finite value something like that.  Any other questions?  Okay. Good song Make The Chew.  of an object's  it takes us a  text Big O of end time.  For r44 are algorithm dijkstra's algorithm. It's going to  doesn't really matter if it takes end timer and log in time because the whole algorithm takes more than n log in time anyway, but  I don't know. Maybe you need this in a different if a different for different purpose, right? It's a nice way to organize data.  And it makes for finding you know, the the lowest value really easy.  Okay, let's move on to another problem minimum spanning trees. Okay. What is a minimum spanning tree? Will first let's define. What is a spanning tree spanning tree is a subgraph of a connected undirected graph. They so we're moving into kind of chapter 5 5.1. We talked about minimum spanning trees and whenever I say Graff I'm always thinking of an undirected.  I should say connected.  connected graph  Okay, so I spanning tree is just a subgraph that's a tree and all of the vertices are in the graph or all of the vertices are connected or the whole graph is connected. So for example, you can have something that looks like this this would be a  spanning tree  something like that the tree so  So any output tree of DFS or BFS is a spanning tree also, right because it contains all the vertices and the output. Is this sort of DFS output tree or BFS output tree.  Okay, so why would you want to do this think about an example where you have like a bunch of computer networks or computers a network of computers that are linked pairwise and each link has some sort of operational maintenance cost. So you want all the computers to stay connected but you want to take get rid of the car that some of the links so that you can save money on the cost. You're going to try to find the minimum spanning tree of that Network right? It's going to be the minimum total cost where you can keep everything connected.  Okay. So the first kind of thing we should think about is does this necessarily have to be a tree?  Does the minimum cost connected graph have to be a tree?  Psy  Okay, good. So when when is it connected graph not a tree is when?  there  Is a cycle?  And then if you cut any of the cycle edges the grass stays connected.  connected  Frank chopp just cut any of those cycle edges and your cost will go down.  Is that assuming everything?  assuming  Edge  weights  are non negative  What would that mean in that computer network? That would mean that one of those networks is actually like generating money. It's tough to dies.  Cuz then you're starting to lose my gas. So let's think I mean this problem actually.  With or without negative edges we can we can still talk about the minimum spanning tree. So but let's think more of positive edges. I like that better or  Cuz of zero edge of kind of like, well, it's sort of like not even there. So it doesn't matter if it's like I says your age would be better than any other Edge.  But let's make a positive edges.  Okay, wait, so why something happened here?  I opened up the wrong thing.  Did I?  Hold on. Let me just see something here.  So your ass.  tube  Okay good.  And have the most updated version here or give me an example of a minimum spanning tree take a few minutes to talk it over with your neighbor just figure out which edges do I need to make a minimum spanning tree?  Let's go with this first. What is the cost?  of the minimum spanning tree  All right. So, what did you guys get for the cost?  12  anybody can do better than that.  Can I see how we can get 12? I think if we do these guys here and the three in the fourth, right. Org. Okay, good. Algorithm you use you might have used let her know a certain type of algorithm to do this or you might have just kind of figured it out or played around with it. So we're going to look at two main algorithms to solve this problem. They're called prims and kruskal. We're going to look at Prince first, okay.  kruskal's kind of is more of the  More obvious way to do it, but prim's algorithm. I wanted to present it now because you'll see it's a lot like what we've just been talking about.  Okay, so prim's algorithm. What what do you want to do? You given a graph with positive Edge weights or  it's just a positive Edge weights and your output is a list of edges that describes the minimum spanning tree, right if I just give you the edges that's enough to reconstruct the tree.  Okay, here's the idea and we're going to do it and sort of like a high-level with sets. So put all of the vertices in you.  pick any random vertex and put it in x  And then repeat this process until all vertices are in X in the process is look at all the edges that cross over the boundary of X meaning all the edges where one endpoint is in X, and the other endpoint is in you.  And out of all of them pick the edge with the lowest weight and then put that put that endpoint in Acts and repeat.  Let's look at how this would work.  Which Edge do you guys want to start from? How about you?  That sound good.  Doesn't matter.  so  that read that red circle that will be X. Okay. So look at all the edges that cross the boundary of xor that start in X and end in you so which one has the lowest weight? Is this one 1/2 G, right?  so  Angie will be part of my output and now you put GNX.  Okay. So now I now you look at only the edges that are crossing over the boundary of X, which one is the lowest.  There's two lowest you can pick either or so. Which one do you want to pick?  about  D  Big D  And now this is acts. So then we have DG.  Okay, and then this one is the lowest right? So we have DEA.  Put that in there.  So now we have three edges of wait to sweep pick any of them. Let's pick this one to see  sorry don't have an animation for this.  AC  and then we also have two edges that are weight to those are both going to be so let's pick. I don't know this one.  Hey B.  And now we can pick any of those edges cuz they're all the same weight. So let's pick this one.  Yeah.  Okay, any questions about that?  Okay, good. So straightforward you understand how it works, right?  I have that again. Okay, that's fine. All right, let's try to go from high-level to a mid-level. So  This is the high-level algorithm that I just presented to you. What we need to do is figure out how to do these operations. I mean, I did it right before your eyes, but I was kind of implying or use common sense and intuition to kind of just figure it out. So with your neighbors discuss how you would Implement prim's algorithm. How would you do these things? And what are the things that I'm asking is well,  How would you find this minimum Edge?  I think that's big the biggest think how would you do that? Okay, ready go.  How do we find the minimum edge with one vertex in X and one vertex in you?  What are my father?  Okay. So before anybody share their their idea, I want to present to you like a a first kind of.  sort of  not a Brute Force way, but kind of a direct way to do this cuz I'm sure some of you seen prims and maybe you have the idea of how to do it efficiently. But let's just think about how do I first do this? Well, my first instinct would say, okay. What I'm going to do is keep  the Boolean array  4X right. So it's basically the visited array right? And so then I'm going to go through all my edges and check to see if one if each endpoint is in Acts and not an ex right then pick the minimum 1 and that'll be my next Edge right and then move the vertex in queso Loop through.  all edges  Check endpoints.  and find minimum  that looks a that crosses.  boundary of x  and then  output  that edge  and then change  Boolean  of that important  Facebook is great because this what does the job it's it's something that will the solve the problem but this is not super efficient, right? Because basically this means that every time you go through  This Loop here. I need to Loop through all the edges and I'm going through this Loop V number of time, right? Because I'm trying to put every vertex into acts. So with this implementation you get a runtime of Big O of the x e  That's a good first step. Anybody want to share their ideas on how to make it more efficient.  From your ex the ones that are connected to the one being when you put something in X put all the edges and priority queue.  Cuz that's when you moved from d2x whenever you do that to me for each of that vertex.  Look at all that.  priority queue  Okay. So every time you move a vertex in two acts put all of its outgoing edges into a priority queue. Okay, so that means that you can have this priority queue fill with edges and you can pick the lowest one each time.  good song  me just kind of  give another slide cuz actually wasn't thinking about doing it that way, but that's great.  Okay, so keep.  a priority queue  of edges  Okay, so then you can use priority. Okay any other ideas?  So we do a priority queue with edges. Let's say we do with you they keep right then every time you do every time you pick a minimum value.  if to do log e many operations  So how long would that run?  Analog E. I guess which is pretty good.  Okay. Maybe it's just  I'm thinking about a different way to do it. But any other  okay.  Well, yeah, if you're if you're talking about anything that like you're going to  the date is going to be more useful to you in sorted order then usually you need like an analog anything but  Okay, so let's let's go to towards what prims algorithm does. So instead of putting a priority queue of edges were going to actually use a priority queue of vertices.  Okay, and so instead of keeping track of the edges, but keep track of the endpoints of those edges cuz those are the things that really matter right? Those are the things. I'm going to be putting into my ex.  Okay. So now we're going to have this cost value for each vertex and we're going to pick the next vertex to put an X based on its cost and what is it cost cost is what is the lightest Edge that's coming from X to that for a text?  Okay, so let's just I just kind of added a few remarks to the other description so you can see where I changed it.  so basically  for all the vertices update the cost to be the weight of the lightest Edge connecting it to a vertex in X right find the minimum Edge this just translates to find the vertex outside of X that has the lowest cost.  And then once you move the edge into X update all the cost again, keep on going see how that works.  queso  I don't have a nice animation, but you can sort of see how it's going to work. Let's do the same starting place. Okay, so  we start with Z 0 and all of these are Infinity, right?  So you put me into X and you update all of its neighbors. So be now becomes 2D becomes 3.  FB comes for  Angie becomes one  then you look at the minimum vertex, right? Cuz that's going to be corresponding to the minimum Edge coming out which is G.  And now update only the neighbors of G because those are the only ones that are going to change once you put that vertex in. So that's where we're going to get the better efficiency.  Okay, and Saudi updates to 2.  Bendy, the orbi is the lowest ones. Let's go a d so put D in there.  and now we get to update a  and so on.  Okay, I'll let you guys.  I have your imagination to how this story ends.  Okay, how do we Implement Prince while when do we update a Vertex? It's only when another vertex is put into X so you can start seeing the the similarities between this and dijkstra's algorithm.  so let's think about it an in kind of  use this cost to make our decisions now initialize all the cost put the whatever vertex in X and then update the cost of all of its neighbors.  then put the lowest cost in 2X and update all of its neighbors and then keep on doing that until everything is in x  queso in Moore  You can sort of see the similarities instead of using disc now. We're using cost and they're just they're both just a raise of numbers. You just update them differently.  So we can use the exact same algorithm structure.  Okay, so let's just go through this quickly.  pick any random vortex  do all the initializations right? So the cost for infinity and all this stuff just like we did before.  And this whole part here.  Is just regular Graph Search like we did before except for we're picking vertices carefully and we're updating the cost and that cost is what we're going to use to pick the next protect. So it's the same thing we did with dijkstra's. Okay, and the way that we update it is.  If its cost is bigger than the weight of the edge that's coming out of the set X then update it to that way.  Okay, and so then we can actually  take dijkstra's algorithm and change only the name disc to cost and then the way that it updates and it's the same thing.  Pretty cool. So let's look at the run time spent all we did was change in a few letters and things like that. We didn't really change the run time. So this shares the same run time as dijkstra's one big difference here is that prims only allows for connected graphs to ever be a input and so all connected graphs have is Big Omega of V.  Because that very worst you have a tree and you have B -1 edges. So so that means that with a binary Heap instead of B plus C Lavie now, it's just you lock me.  Okay, and that backslash didn't compile this fine?  And then the array is also vsquare so you get the same sort of thing.  Okay, any questions about that?  Nobody's curious about the correctness.  You just trust that it works since it's in the book and has a fancy name. It'll work. Well luckily for you guys or maybe unluckily for you guys. You're going to have to wait till next week for the correctness proof.  But before you guys go.  Sorry.  The next thing we're going to do is the greedy approach. So if you already know what it is then read up on it, and if you don't then think about what does that mean the greedy approach try to keep on at the next Edge that will contribute the least amount to each thing.  was that  I posted today and I also posted some practice problems for the quiz. Yeah.  Bank of America number 105 should come a different time. Are you free this afternoon or this evening? No, but next week I can do next week. Yeah, I would like some I would appreciate some! I totally get it. Yeah. Sure.  I don't know maybe even Monday you can come talk to me after class.  Bring back the Cookie Monster example for the greedy.  Did you like that? Alright, I'll do that. "
}