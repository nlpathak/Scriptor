{
  "Blurbs": {
    "2. Then you pick this one for Room 2. Okay, and then you pick front one from room 3. Okay, so why is this a counterexample? You couldn't get the picture. Vine wine pairing two and then right what students at woman 1/3 then? You could do use it you could do two rooms, right? Basically you swap these to write. Or you you put the the bottom one into ": [
      706.6,
      759.0
    ],
    "A over B to the D is greater than 1 and you have that this summation kind of acts like an exponential and that's why you get this and you guys can use a exercise maybe to show that why those people so that's where all of these things come from. You have the top-heavy the steady-state and the bottom heavy so you don't have to prove this every time ": [
      2957.6,
      2985.9
    ],
    "Cool. Thank you. I'm just going to hold this for a second. Actually, you know of a good would be to give a a place to draw it. Did you do? Okay. say Okay. Does anybody have a counterexample this one's kind of tricky? Kind of gives you a sense of you know, sometimes they're not so obvious why they're counter-examples. Okay. Well, let's just see the one that I ": [
      483.1,
      579.9
    ],
    "D. If a is equal to B to the D, then you have A over B to the D is equal to 1. And so that some is linear in in with respect to the upper bound of the summation. Basically, you're just Adding One log b-event many times. So that's why you get this one. and then finally He is greater than b to the D. Then you have ": [
      2927.8,
      2957.6
    ],
    "I guess I guess I don't know exactly how you would do it without kind of giving the rooms names, right? Which room are you going to put it in? Because you're going to have to reuse rooms right in order to get the optimal strategy. So how do you know which rooms are which Okay. Okay. But really what the story with the latest finish time in that room ": [
      1582.2,
      1623.5
    ],
    "Listen to a podcast. Okay. Good afternoon, everyone. How's everyone doing? Does anybody have any? Questions or comments before we begin? No. All right, let's get started then. Alright, so today we're going to Let's get that thing off. We're going to finish up that same example from from the last class and then we'll move on into divide and conquer so this will be like the last day we ": [
      1.9,
      93.3
    ],
    "Then I claim at some point K is going to be less than or equal to be of tea. In fact, it's going to be exactly equal to Beauty. at some tea okay, so the idea here is Let's figure out. When did I first need to use that room K. When did I first need to use that last room will the only reason I needed to use it ": [
      934.1,
      962.8
    ],
    "a power of two if you like and then it and then I'll always be able to divide. Okay, so now we got a better. runtime Okay, so let's run through a how to solve these using the master theorem. Okay, so most Divide and conquer algorithms will give you a recursion that looks like this. So we're going to figure out how to solve it for everything. I know ": [
      2479.2,
      2511.5
    ],
    "a priority queue of available rooms ordered by or their key would be there room number A Min Heap. So then you go through the start times when an event starts. You assign it to the smallest possible room in the priority queue and then delete that room from the from the Q until that event ends and then put it back in and then you just kind of have ": [
      1736.4,
      1762.5
    ],
    "a start. I and a finish I And the solution format is an assignment. of each event to a room maybe you can think about this is like ordered pairs where like maybe event one goes into room through not event want but maybe event 5 goes into room 3 Okay, the constraints are that no two events in the same. room overlap And the objective is to minimize. I ": [
      1107.4,
      1164.3
    ],
    "alarm for 4 p.m. Has anybody have any? High-level description of how to implement where I guess it would be like a mid-level implementation level description on how to do this. wait But different than what we had. Find a new route with number we find start time for all events by their end. in the store in the park you make a message on Instagram and then when you ": [
      1313.8,
      1494.8
    ],
    "algorithm works. Whenever X has K digits and why has K digits for nek in between 1 and 1 + -1 really? Okay. So then by the inductive hypothesis those R1 R2 and R3 are they actual correct products of those binary strings? Play some now. The only thing we have to do is show that combining those things together gives you the product of the original. input Okay, so ": [
      2368.2,
      2414.0
    ],
    "any questions about that? What if I did this? What happens if R is equal to 1 then? What is the sum equal to? You guys should know this closed form. Okay good. So actually thinking about this. In terms of our this thing behave differently for different values of our we've already seen that it would behave differently if R is equal to one or of our is not ": [
      2576.3,
      2621.3
    ],
    "as an exercise to show that these are equivalent. So basically what we're saying is that this is how long it takes for each level based on K there are and there are log base B of and many levels so you add them all up and you get this summation. Frank from K down to zero all the way up to log base B event. So then what is ": [
      2866.3,
      2898.4
    ],
    "be kind of a the you know. the main way that you build a divide-and-conquer algorithm you give it a name so x x y where X Y X + wire and Bitter End bit integers and the output is the product XY you have your base case. And then you split it up. Split it up. and then you do your recursive calls Anza problems now, what is the ": [
      2062.8,
      2109.6
    ],
    "because that is your reducing it at every single recursive call, you're going to save a lot of time. Okay. So multiplying let's just talk about it as multiplying binary numbers. You can do it the grade school way. And if you like you can you can convince yourself that this is going to take Big O of N squared time. Basically, you're multiplying every single pair of numbers right ": [
      1901.4,
      1933.2
    ],
    "bound right and that's because that at this time at time T. You need at least four rooms. And so you can kind of mathematically go through it, but this is just the the main idea. So we're just going to kind of let me just go back through this stuff. I think we kind of talked about it already, but What's a BMT is the set of all events ": [
      849.8,
      877.9
    ],
    "breathe Whenever we can get an A. earlier than album Okay, but then how do you know which room to assign it to? I'm not coming home. of the room count and you only when do you increment the number of rooms? Okay. Okay, but you're going to kind of start assigning rooms that you might not need, right? I guess. So you're going to put the first one into ": [
      1494.8,
      1582.2
    ],
    "came up with last year. Okay. So let's say you have one event that goes from 3 to 7. Okay, let's say another event goes from 7 to 11. Guy and another event that goes from 5 to 10. Another event that goes from 10 to 14. Add another event that goes from 11 to 13. And another event that goes from 13 to 19. And then my last event ": [
      579.9,
      644.7
    ],
    "can think about that is running in like a linear time thing at worst Frank just kind of feel in these new strings and then this addition here while we're going to assume that Edition takes linear time on itself. So this will be a linear time addition. so they're non recursive part is Big O of n yes. Right. So * 2 ^ n r ^ n / 2 ": [
      2154.3,
      2189.9
    ],
    "do greedy stuff. I hope that I've given you enough examples. There's some more examples that you can get from the notes from discussion. Right and then I'll be posting some more problem somewhere greedy algorithm problems that you can practice on. That won't be for turning in that would just kind of be like a practice quiz type problem. So I'll post those maybe today I guess the quiz ": [
      93.3,
      124.8
    ],
    "do this? Okay, and they came up with something that I have a funny feeling is a not not always optimal but I was trying to figure out a counterexample. So maybe you guys this would be a good exercise for you to try to come up with it. Okay. So here's the problem. You have a conference room to plan with any events and you have an unlimited supply ": [
      193.6,
      221.4
    ],
    "equal to one. But it also as n goes to Infinity this thing behaves differently if AR is less than one in ours greater than one. Okay. If R is less than 1 then this thing is actually constant right? It's it's it conversions. So it has an upper bound. So it's constant time if you think about an algorithm running in this amount of time. If R is equal ": [
      2621.3,
      2648.4
    ],
    "equal to the pound l. Okay, so this is sort of The main strategy is to show that there's a bound and then showed the greedy solution achieves that bound and then you're done. Because if it's less than one if it's less than it at some point then then you take the max overall points has got to be less than the max. It's less than or equal to ": [
      1024.5,
      1066.5
    ],
    "events going on at the same time there for at that point K is greater than is less than or equal to be of tea or actually more specifically K is equal to 50. so if it's if it's equal to be a t at some point, then that means it's got to be. Less than or equal to the max overall the bmt's and therefore it's got to be ": [
      989.3,
      1024.5
    ],
    "get a better run time. So now we just have a few minutes left. So I'm going to kind of go through this kind of quickly since I know you've seen it before but I want you to see it again. So we have a good understanding. Okay, so during the case level of that of that tree. What have you done? What you've done a to the K many ": [
      2807.3,
      2832.7
    ],
    "get to it exactly today, but We can kind of start. Getting more and more efficient algorithms by taking it step a few steps farther. Okay, so here's the idea when you multiply binomials. It requires for multiplications. a x + b x c x + D you need to multiply a c a d e b c and b d But what we can do. Is if we assume ": [
      1823.3,
      1865.4
    ],
    "goes from 16 to 18. I just put it up here I guess. Okay, so let's talk about why this would be a counterexample. So the that you use the algorithm which says pick the one that has the earliest end time in and kind of fill up room one with those. Okay. So, let's see which ones we pick we we're going to pick this one for room one, ": [
      644.7,
      671.7
    ],
    "guys can verify this as an exercise and then you show that it's equal to that which is equal to XY right? So it's just kind of algebra and that's the end of the proof. So these proofs are usually pretty easy to do. Sure, that that won't ruin it. Yeah, but this one in particular you can just pad the the the bit strings with zeros until you reach ": [
      2439.8,
      2479.2
    ],
    "half of digits. Now we have we're basically dividing it into some problems and we're going to use our algorithm to solve this a problems. Okay, here's kind of the key Insight is that to do this one of your One of your sub problems XR is just that binary number but XL is going to be that binary number with a bunch of zeros on it right with an ": [
      1958.6,
      1989.7
    ],
    "in the master theorem. Okay, so let's kind of break it down into these cases. Okay, so think about a divide-and-conquer problem that you split up the original problem. And this case I'm splitting it up into four, but you can just think about it as you're splitting it up into a different problems each of size and over be right. And then you have a square different problem teacher ": [
      2684.5,
      2714.0
    ],
    "induction because you're usually dividing it into two or dividing it into for something like that. Okay, so I just want to go through this because when you guys do your proofs I want them to be this type of induction. So base case is usually just the base case of the algorithm. So when n is equal to 1 then return XY you can make a table of the ": [
      2301.6,
      2324.5
    ],
    "instead of those for multiplications they have two of the same ones. And then they add them together first and then recursively call on their son. And so we have our one is the same as before. Our two is the same as before and then are 3 - ardoin - R2 that turns out to be that middle term you guys can See that this is true if you ": [
      2226.2,
      2264.8
    ],
    "is in a week, so maybe today or tomorrow so you have some more Practice and then I'll post the solutions and I'll post the solutions to the homework and the practice problems. Maybe all on Monday will be good to look over so you kind of know the the idea that any questions about that All right. So so this last example is the way we're going to prove ": [
      124.8,
      159.2
    ],
    "it is to use the achieved the bound technique proved strategy and we kind of looked at it already, but let's go over it again. and what I wanted to do was you guys probably all remember. how to do it but what I wanted to do is maybe think about it cuz I talked to the last class. I mean the the 4 class. And wait, how do I ": [
      159.2,
      193.6
    ],
    "just want to give you a sense of why it works. Okay. So now we can just use it without proof and your homework in the quiz, whatever you like. Okay. Have a nice weekend everyone. Can you see San Diego podcast? ": [
      2985.9,
      3002.2
    ],
    "let's just do that. It's just some algebra. This is what the algorithm returns so start with that what it how does it combine them and show that the combination actually gives you what you want. Right? Well, we get our 1 to the end this whole thing to the end / 2 + R2. We got XL / x l y l x r y r and then you ": [
      2414.0,
      2439.8
    ],
    "like a 3 the three steps of divide and conquer break the problem up into simpler subproblems. Solvista problem recursively and then combine. Okay. So we're going to start off with multiplication. I know that in 21 we did this also, so those of you taking 21 this might be kind of a review but we're going to we're going to take it a few steps farther. You might not ": [
      1795.0,
      1823.3
    ],
    "like this and it's going to get messy. But you have to do every single possible multiplication. Then you have to do a bunch of petitions. Okay, so what would it look like to do this divide and conquer? So the idea here is to split up X and Y which would be are binary numbers and split them up until like the left half of digits in the right ": [
      1933.2,
      1958.6
    ],
    "like to call it the maximum. room number Nice to kind of figure out what you're trying to do. Okay, so now I want to give you guys a few minutes. How would you implement this particular greedy strategy? Okay, ready go. Do you like maybe if you want to look at this or this one maybe is better. maximum to be used for education fat in stool Set an ": [
      1164.3,
      1313.8
    ],
    "of operations you need increases so we call this a bottom-heavy algorithm because most of the work is done at the at the bottom level and then it kind of goes up. Okay, when we do it in two three now, you can see instead of 2 and 4. I'm getting 1.5 + 1.5 squared so it's still bottom-heavy, but it's not growing as much and so you're going to ": [
      2779.4,
      2807.3
    ],
    "of rooms you want to book? events two rooms in such a way as to minimize the number of rooms Okay, so I have this one doesn't work. Okay, so this is a candidate. greedy strategy One, okay. So what is it going to do is? Use the event. scheduling algorithm from before right the one where you pick the earliest end time use event scheduling algorithm to fill room ": [
      221.4,
      275.9
    ],
    "of tea rooms. So in total you need at least be a few rooms for all-time. Therefore we get that L being the maximum over all of these sizes of sets has got to be the lower Bound for all solutions. Okay, so now let's talk about how the greedy solution actually achieved this bound. So let's say that K is the number of rooms given by the greedy solution. ": [
      906.6,
      934.1
    ],
    "one right with events then. then repeat with remaining events crank seems pretty good. Right but it doesn't work all the time. So I want you guys to think about can you come up with a counterexample for this algorithm ready to go? Play make sure my my thinking is correct on this to my outline counterexample. Okay, so you pick this one? 9 Call Block Tango. I found it. ": [
      275.9,
      482.0
    ],
    "over two zeros added to it. So really mathematically this is The same thing as putting your number into two halves. Okay, let's go back to what it takes to multiply binomials together. But I'm going to instead look at these two binomials. Okay, let's multiply these two binomials together and you'll see that it's a lot like what we had before we have a two to the end times ": [
      1989.7,
      2024.9
    ],
    "possibilities. There's only for right when you multiply 0 * 008 * 121 * 2/1 * 1 so then that's all. inductive hypothesis We're going to have to do a strong inductive hypothesis. because sub problem size is less than and -1 goes all the way down to end mine then over to. Okay. So this is the strong induction hypothesis for some and greater than 1 assume that your ": [
      2324.5,
      2368.2
    ],
    "right? Then what's the next one we pick is this one, right? for room one and then the next one we pick is this one for room one, right? And then the next one we pick would be this one for room one. That kind of makes sense. Okay, so then you put all those in room one and then how about room to You pick this one for Room ": [
      671.7,
      706.6
    ],
    "room one and then you put that one into room two and it'll be fine. Okay, any questions pretty tricky, huh? Maybe that'll be some challenge exercise. I mean, I think you're going to have to have at least like at least a problem that has two rooms. where that where are the minimum number of rooms has to yeah, you can maybe find one. Okay, let's move on. So ": [
      759.0,
      816.4
    ],
    "runtime of this? Well, it basically just gives you a Tia van right gives you a recursion you have for recursive calls, each of size and / 2. right And then how long does it take to do the non recursive part? Well, what is the non recursive part? It's basically doing the base case, which is just a constant time check splitting up these bits these binary strings we ": [
      2109.6,
      2154.3
    ],
    "size and over B squared and so on down to the lower case where you have size one. That's when you can put in the base case. Okay, so What the original multiplication algorithm that we saw where we divided into four. This would be kind of what it looks like, right? So you please put up into four problems each of size and over to write and in order ": [
      2714.0,
      2746.3
    ],
    "subproblems each of size n over B to the k? And you're going to have to have combined them together in end to the D time but you're only combining little sub problems. So it's only going to take Andover be to the cage to the Andover be to the K2 the D time. Okay, so that's why you get this whole thing here. and you guys can do this ": [
      2832.7,
      2866.3
    ],
    "that Edition is cheap, which we know is efficient, which it is. It has a short run time. Then we can improve this by only doing three multiplications. So this is the karatsuba. approach so that's what we're going to talk about today for the remainder of the class. Basically. Okay, so it may not seem like it's very impressive. It's just kind of reducing it by a constant but ": [
      1865.4,
      1901.4
    ],
    "that are happening at time T. Right then if R is the number of rooms at an arbitrary valid schedule you need the number of rooms has to be bigger than or equal to be of tea for all tea because you need to be able to to fit all the events in at all times. And the proof idea is my friendy time to you need at least be ": [
      877.9,
      906.6
    ],
    "that most of you guys have seen this before I wanted to go into it in a little bit more detail so that you have an understanding of why the master theorem is what it is. Let's start off with the Geometric series does anybody know what the closed form of this thing is? Arts of the n + 1 - 1 / r - 1 no, you mean yes ": [
      2511.5,
      2576.3
    ],
    "that's not an actual multiplication that we need the algorithm for right? Cuz you're just shifting. Okay good. So we get this recursion. these guys karatsuba and coma gaurav they were able to Reduce the number of multiplications needed and they traded it for some additions and subtractions. So, let's see what that looks like. So it's the same type of algorithm. We're going to call it X KS. And ": [
      2189.9,
      2226.2
    ],
    "this sort of priority queue that you keep on popping things and pulling things in and I guess once the priority queue is empty then you you put it you put the next number room in there. any questions Okay, let's see. Let's kind of This is going to be the end of greedy strategies and we're going to start talking about divide and conquer. Okay, so let's just give ": [
      1762.5,
      1795.0
    ],
    "this summation look like it's basically a geometric Series, right? So it's behavior is dependent on how are relates to be to the D. Does the same thing like we did before if a is less than b to the D? That means that A over B to the D is less than 1. So, you know that that sum converges and all you're left with is end-to-end to the ": [
      2898.4,
      2927.8
    ],
    "those rooms may take up to n time, right? So be like + sqrt, right? Okay good. Any other ideas? Anybody think about using a priority queue for the rooms? Something like this maybe. Do you sort it for you sorted the the the start time and the end times we have two sorted lists, so you can kind of go through both of them. Right and then you keep ": [
      1701.5,
      1736.4
    ],
    "to 1 then we get nplusone and we get linear time. And if R is greater than 1 then this is just an exponential function and our this sum is actually big of art to the end. Okay, so we get this nice. kind of three different scenarios based on what the value of R is here. So these are the three scenarios. That's what gives you the three cases ": [
      2648.4,
      2684.5
    ],
    "to combine those all back up to the original problem. You have to do it four times, right? So you basically add to x c x and many operations. Can't bend as you go down. Now. You have 16 problems all size and over for right? So now you're adding a 4 x c x in okay, and as you can see as you go down these levels the number ": [
      2746.3,
      2779.4
    ],
    "to the most recent end of time in that room. Okay, so room has Valu Rite finish of that room, right which is the the finish time of the set of events scheduled for that room up to that point. Okay. Okay, so then search through. rooms for each event until you find and available available. Okay, that'll work. How long is that going to take? I've been searching through ": [
      1623.5,
      1701.5
    ],
    "want like as an exercise. Exercise is to check. Okay. So let's just go through the correctness of this algorithm really fast these divide and conquer algorithms. The correctness proofs are usually just a very simple induction. You just basically say I have faith the algorithm will work on a certain size show that it works on the next size would divide and conquer usually have to do a strong ": [
      2264.8,
      2301.6
    ],
    "was because it was the minimum number of available room, which means that there were events going on in all the rooms 1 through K - 1 so that means that what they're worth Kay events going on, right? And so the size of be of tea at that moment was equal to K. So you had to have that many rooms. Can meet at time T. They were K ": [
      962.8,
      989.3
    ],
    "what is the algorithm that we're going to use is you just kind of order the events by when they start and keep on putting an event into the minimum number available room where the rooms are numbered 1 through infinity or whatever. Okay, so we saw this picture before and it would give you four rooms. Now. The reason that 4 is the lowest number of rooms it's the ": [
      816.4,
      849.8
    ],
    "why you actually can't get less than because we prove that that bound was the lowest possible number of rooms. Okay, so in conclusion Yeah, this is kind of basically what we just said. So let's move on to the implementation. Okay event scheduling with multiple rooms. What is the instance while we have any events? C1 through Eat Right each with a start time less AEI is equal to ": [
      1066.5,
      1107.4
    ],
    "xly I'll move it to the end over 2 times the sum and we have an x r y r I'm so naively if you wanted to do this problem you could recurse. recurse on x l y l x l y r x r y l and X are y are right and do for recursive calls? And your algorithm might look something like this. This is going to ": [
      2024.9,
      2062.8
    ]
  },
  "Class Name": "cse101",
  "Date": "02082019",
  "Full Transcript": "Listen to a podcast.  Okay. Good afternoon, everyone.  How's everyone doing?  Does anybody have any?  Questions or comments before we begin?  No.  All right, let's get started then.  Alright, so today we're going to  Let's get that thing off.  We're going to finish up that same example from from the last class and then we'll move on into divide and conquer so this will be like the last day we do greedy stuff. I hope that I've given you enough examples.  There's some more examples that you can get from the notes from discussion. Right and then I'll be posting some more problem somewhere greedy algorithm problems that you can practice on. That won't be for turning in that would just kind of be like a practice quiz type problem. So I'll post those maybe today I guess the quiz is in a week, so maybe today or tomorrow so you have some more  Practice and then I'll post the solutions and I'll post the solutions to the homework and the practice problems. Maybe all on Monday will be good to look over so you kind of know the  the idea that any questions about that  All right. So so this last example is  the way we're going to prove it is to use the achieved the bound technique proved strategy and we kind of looked at it already, but let's go over it again.  and what I wanted to do was  you guys probably all remember.  how to do it  but what I wanted to do is maybe think about it cuz I talked to the last class. I mean the the 4 class.  And wait, how do I do this?  Okay, and they came up with something that  I have a funny feeling is a not not always optimal but I was trying to figure out a counterexample. So maybe you guys this would be a good exercise for you to try to come up with it. Okay. So here's the problem.  You have a conference room to plan with any events and you have an unlimited supply of rooms you want to book?  events two rooms in such a way as to minimize the number of rooms Okay, so  I have this one doesn't work.  Okay, so this is a candidate.  greedy strategy  One, okay. So what is it going to do is?  Use the event.  scheduling  algorithm  from before right the one where you pick the earliest end time use event scheduling algorithm to fill room one right with events then.  then repeat  with remaining events  crank seems pretty good. Right but it doesn't work all the time. So I want you guys to think about can you come up with a counterexample for this algorithm ready to go?  Play make sure my my thinking is correct on this to my outline counterexample.  Okay, so you pick this one?  9  Call Block Tango.  I found it.  Cool. Thank you. I'm just going to hold this for a second.  Actually, you know of a good would be to  give a a place to draw it.  Did you do?  Okay.  say  Okay. Does anybody have a counterexample this one's kind of tricky?  Kind of gives you a sense of you know, sometimes they're not so obvious why they're counter-examples.  Okay. Well, let's just see the one that I came up with last year.  Okay. So let's say you have one event that goes from 3 to 7.  Okay, let's say another event goes from 7 to 11.  Guy and another event that goes from 5 to 10.  Another event that goes from 10 to 14.  Add another event that goes from 11 to 13.  And another event that goes from 13 to 19.  And then my last event goes from 16 to 18.  I just put it up here I guess.  Okay, so let's talk about why this would be a counterexample.  So the that you use the algorithm which says pick the one that has the earliest end time in and kind of fill up room one with those. Okay. So, let's see which ones we pick we we're going to pick this one for room one, right?  Then what's the next one we pick is this one, right?  for room one  and then the next one we pick is  this one for room one, right?  And then the next one we pick would be this one for room one.  That kind of makes sense.  Okay, so then you put all those in room one and then how about room to  You pick this one for Room 2.  Then you pick this one for Room 2.  Okay, and then you pick front one from room 3.  Okay, so why is this a counterexample?  You couldn't get the picture.  Vine wine pairing  two and then right  what students at woman 1/3 then?  You could do use it you could do two rooms, right? Basically you swap these to write.  Or you you put the the bottom one into room one and then you put that one into room two and it'll be fine.  Okay, any questions pretty tricky, huh?  Maybe that'll be some challenge exercise.  I mean, I think you're going to have to have at least like at least  a problem that has two rooms.  where that where are the minimum number of rooms has to  yeah, you can maybe find one.  Okay, let's move on. So what is the algorithm that we're going to use is you just kind of order the events by when they start and keep on putting an event into the minimum number available room where the rooms are numbered 1 through infinity or whatever.  Okay, so we saw this picture before and it would give you four rooms. Now. The reason that 4 is the lowest number of rooms it's the bound right and that's because that at this time at time T. You need at least four rooms.  And so you can kind of mathematically go through it, but this is just the the main idea. So we're just going to kind of let me just go back through this stuff. I think we kind of talked about it already, but  What's a BMT is the set of all events that are happening at time T. Right then if R is the number of rooms at an arbitrary valid schedule you need the number of rooms has to be bigger than or equal to be of tea for all tea because you need to be able to to fit all the events in at all times. And the proof idea is my friendy time to you need at least be of tea rooms. So in total you need at least be a few rooms for all-time. Therefore we get that L being the maximum over all of these sizes of sets has got to be the lower Bound for all solutions.  Okay, so now let's talk about how the greedy solution actually achieved this bound. So let's say that K is the number of rooms given by the greedy solution. Then I claim at some point K is going to be less than or equal to be of tea. In fact, it's going to be exactly equal to Beauty.  at some tea  okay, so the idea here is  Let's figure out. When did I first need to use that room K. When did I first need to use that last room will the only reason I needed to use it was because it was the minimum number of available room, which means that there were events going on in all the rooms 1 through K - 1 so that means that what they're worth Kay events going on, right? And so the size of be of tea at that moment was equal to K. So you had to have that many rooms.  Can meet at time T. They were K events going on at the same time there for at that point K is greater than is less than or equal to be of tea or actually more specifically K is equal to 50.  so  if it's if it's equal to be a t at some point, then that means it's got to be.  Less than or equal to the max overall the bmt's and therefore it's got to be equal to the pound l.  Okay, so this is sort of  The main strategy is to show that there's a bound and then showed the greedy solution achieves that bound and then you're done.  Because if it's less than one if it's less than it at some point then then you take the max overall points has got to be less than the max.  It's less than or equal to why you actually can't get less than because we prove that that bound was the lowest possible number of rooms.  Okay, so in conclusion  Yeah, this is kind of basically what we just said.  So let's move on to the implementation. Okay event scheduling with multiple rooms. What is the instance while we have any events?  C1 through Eat Right each with a start time less AEI is equal to a start. I and a finish I  And the solution format is an assignment.  of each  event to a room  maybe you can think about this is like ordered pairs where like maybe event one goes into room through not event want but maybe event 5 goes into room 3  Okay, the constraints are that no two events in the same.  room overlap  And the objective is to minimize.  I like to call it the maximum.  room number  Nice to kind of figure out what you're trying to do.  Okay, so now I want to give you guys a few minutes.  How would you implement this particular greedy strategy? Okay, ready go.  Do you like maybe if you want to look at this or this one maybe is better.  maximum to be used for education  fat in stool  Set an alarm for 4 p.m.  Has anybody have any?  High-level description of how to implement where I guess it would be like a mid-level implementation level description on how to do this.  wait  But different than what we had.  Find a new route with number we find start time for all events by their end.  in the store in the park you make a message on Instagram and then when you breathe  Whenever we can get an A.  earlier than album  Okay, but then how do you know which room to assign it to?  I'm not coming home.  of the room count  and you only when do you increment the number of rooms?  Okay.  Okay, but you're going to kind of start assigning rooms that you might not need, right?  I guess.  So you're going to put the first one into I guess I guess I don't know exactly how you would do it without kind of giving the rooms names, right? Which room are you going to put it in? Because you're going to have to reuse rooms right in order to get the optimal strategy. So how do you know which rooms are which  Okay.  Okay.  But really what the story with the latest finish time in that room to the most recent end of time in that room. Okay, so room  has  Valu Rite finish  of that room, right which is the the finish time of the set of events scheduled for that room up to that point. Okay.  Okay, so then search through.  rooms  for each event  until you find  and available available.  Okay, that'll work. How long is that going to take?  I've been searching through those rooms may take up to n time, right? So be like + sqrt, right?  Okay good.  Any other ideas?  Anybody think about using a priority queue for the rooms?  Something like this maybe.  Do you sort it for you sorted the the the start time and the end times we have two sorted lists, so you can kind of go through both of them. Right and then you keep a priority queue of available rooms ordered by or their key would be there room number A Min Heap.  So then you go through the start times when an event starts.  You assign it to the smallest possible room in the priority queue and then delete that room from the from the Q until that event ends and then put it back in and then you just kind of have this sort of priority queue that you keep on popping things and pulling things in and I guess once the priority queue is empty then you you put it you put the next number room in there.  any questions  Okay, let's see. Let's kind of  This is going to be the end of greedy strategies and we're going to start talking about divide and conquer. Okay, so let's just give like a  3  the three steps of divide and conquer break the problem up into simpler subproblems.  Solvista problem recursively and then combine. Okay. So we're going to start off with multiplication. I know that in 21 we did this also, so those of you taking 21 this might be kind of a review but we're going to we're going to take it a few steps farther. You might not get to it exactly today, but  We can kind of start.  Getting more and more efficient algorithms by taking it step a few steps farther.  Okay, so here's the idea when you multiply binomials.  It requires for multiplications.  a x + b x c x + D you need to multiply  a c a d e b c and b d  But what we can do.  Is if we assume that Edition is cheap, which we know is efficient, which it is. It has a short run time. Then we can improve this by only doing three multiplications. So this is the karatsuba.  approach  so that's what we're going to talk about today for the remainder of the class. Basically. Okay, so it may not seem like it's very impressive. It's just kind of reducing it by a constant but because that is your reducing it at every single recursive call, you're going to save a lot of time.  Okay.  So multiplying let's just talk about it as multiplying binary numbers. You can do it the grade school way. And if you like you can you can convince yourself that this is going to take Big O of N squared time.  Basically, you're multiplying every single pair of numbers right like this and it's going to get messy. But you have to do every single possible multiplication. Then you have to do a bunch of petitions.  Okay, so what would it look like to do this divide and conquer?  So the idea here is to split up X and Y which would be are binary numbers and split them up until like the left half of digits in the right half of digits.  Now we have we're basically dividing it into some problems and we're going to use our algorithm to solve this a problems.  Okay, here's kind of the key Insight is that to do this one of your  One of your sub problems XR is just that binary number but XL is going to be that binary number with a bunch of zeros on it right with an over two zeros added to it. So really mathematically this is  The same thing as putting your number into two halves.  Okay, let's go back to what it takes to multiply binomials together. But I'm going to instead look at these two binomials. Okay, let's multiply these two binomials together and you'll see that it's a lot like what we had before we have a two to the end times xly I'll move it to the end over 2 times the sum and we have an x r y r  I'm so naively if you wanted to do this problem you could recurse.  recurse  on x l y l x l y r  x r y l and X are y are right and do for recursive calls?  And your algorithm might look something like this.  This is going to be kind of a the you know.  the main way that you build a divide-and-conquer algorithm you give it a name so x x y  where X Y X + wire and Bitter End bit integers and the output is the product XY you have your base case.  And then you split it up.  Split it up.  and then you do your  recursive calls  Anza problems  now, what is the runtime of this? Well, it basically just gives you a  Tia van right gives you a recursion you have for recursive calls, each of size and / 2.  right  And then how long does it take to do the non recursive part?  Well, what is the non recursive part? It's basically doing the base case, which is just a constant time check splitting up these bits these binary strings we can think about that is running in like a linear time thing at worst Frank just kind of feel in these new strings and then this addition here while we're going to assume that Edition takes linear time on itself. So this will be a linear time addition.  so they're non recursive part is Big O of n  yes.  Right. So * 2 ^ n r ^ n / 2 that's not an actual multiplication that we need the algorithm for right? Cuz you're just shifting.  Okay good. So we get this recursion.  these guys karatsuba and coma gaurav they were able to  Reduce the number of multiplications needed and they traded it for some additions and subtractions. So, let's see what that looks like. So it's the same type of algorithm. We're going to call it X KS.  And instead of those for multiplications they have two of the same ones.  And then they add them together first and then recursively call on their son.  And so we have our one is the same as before. Our two is the same as before and then are 3 - ardoin - R2 that turns out to be that middle term you guys can  See that this is true if you want like as an exercise.  Exercise is to check.  Okay. So let's just go through the correctness of this algorithm really fast these divide and conquer algorithms. The correctness proofs are usually just a very simple induction. You just basically say I have faith the algorithm will work on a certain size show that it works on the next size would divide and conquer usually have to do a strong induction because you're usually dividing it into two or dividing it into for something like that.  Okay, so I just want to go through this because when you guys do your proofs I want them to be this type of induction. So base case is usually just the base case of the algorithm. So when n is equal to 1 then return XY you can make a table of the possibilities. There's only for right when you multiply 0 * 008 * 121 * 2/1 * 1 so then that's all.  inductive hypothesis  We're going to have to do a strong inductive hypothesis.  because  sub problem  size  is less than  and -1 goes all the way down to end mine then over to.  Okay. So this is the strong induction hypothesis for some and greater than 1  assume that your algorithm works.  Whenever X has K digits and why has K digits for nek in between 1 and 1 + -1 really?  Okay.  So then by the inductive hypothesis those R1 R2 and R3 are they actual correct products of those binary strings?  Play some now. The only thing we have to do is show that combining those things together gives you the product of the original.  input  Okay, so let's just do that. It's just some algebra.  This is what the algorithm returns so start with that what it how does it combine them and show that the combination actually gives you what you want. Right? Well, we get our 1 to the end this whole thing to the end / 2 + R2. We got XL / x l y l x r y r and then  you guys can  verify this  as an exercise  and then you show that it's equal to that which is equal to XY right? So it's just kind of algebra and that's the end of the proof. So these proofs are usually pretty easy to do.  Sure, that that won't ruin it.  Yeah, but this one in particular you can just pad the the the bit strings with zeros until you reach a power of two if you like and then it and then I'll always be able to divide.  Okay, so now we got a better.  runtime  Okay, so let's run through a how to solve these using the master theorem.  Okay, so most  Divide and conquer algorithms will give you a recursion that looks like this. So we're going to figure out how to solve it for everything. I know that most of you guys have seen this before I wanted to go into it in a little bit more detail so that you have an understanding of why the master theorem is what it is.  Let's start off with the  Geometric series does anybody know what the closed form of this thing is?  Arts of the n + 1 - 1 / r - 1  no, you mean  yes any questions about that?  What if I did this?  What happens if R is equal to 1 then? What is the sum equal to?  You guys should know this closed form.  Okay good.  So actually thinking about this.  In terms of our this thing behave differently for different values of our we've already seen that it would behave differently if R is equal to one or of our is not equal to one.  But it also as n goes to Infinity this thing behaves differently if AR is less than one in ours greater than one. Okay. If R is less than 1 then this thing is actually constant right? It's it's it conversions. So it has an upper bound. So it's constant time if you think about an algorithm running in this amount of time.  If R is equal to 1 then we get nplusone and we get linear time.  And if R is greater than 1 then this is just an exponential function and our this sum is actually big of art to the end.  Okay, so we get this nice.  kind of  three different scenarios based on what the value of R is here. So these are the three scenarios. That's what gives you the three cases in the master theorem.  Okay, so let's kind of break it down into these cases.  Okay, so think about a divide-and-conquer problem that you split up the original problem. And this case I'm splitting it up into four, but you can just think about it as you're splitting it up into a different problems each of size and over be right.  And then you have a square different problem teacher size and over B squared and so on down to the lower case where you have size one. That's when you can put in the base case.  Okay, so  What the original multiplication algorithm that we saw where we divided into four. This would be kind of what it looks like, right? So you please put up into four problems each of size and over to write and  in order to combine those all back up to the original problem.  You have to do it four times, right? So you basically add to x c x and many operations.  Can't bend as you go down. Now. You have 16 problems all size and over for right? So now you're adding a 4 x c x in  okay, and as you can see as you go down these levels the number of operations you need increases so we call this a bottom-heavy algorithm because most of the work is done at the at the bottom level and then it kind of goes up.  Okay, when we do it in two three now, you can see instead of 2 and 4. I'm getting 1.5 + 1.5 squared so it's still bottom-heavy, but it's not growing as much and so you're going to get a better run time.  So now we just have a few minutes left. So I'm going to kind of go through this kind of quickly since I know you've seen it before but I want you to see it again. So we have a good understanding.  Okay, so during the case level of that of that tree. What have you done? What you've done a to the K many subproblems each of size n over B to the k?  And you're going to have to have combined them together in end to the D time but you're only combining little sub problems. So it's only going to take Andover be to the cage to the Andover be to the K2 the D time.  Okay, so that's why you get this whole thing here.  and  you guys can do this as an exercise to show that these are equivalent.  So basically what we're saying is that this is how long it takes for each level based on K there are and there are log base B of and many levels so you add them all up and you get this summation.  Frank from K down to zero all the way up to log base B event.  So then  what is this summation look like it's basically a geometric Series, right? So it's behavior is dependent on how are relates to be to the D.  Does the same thing like we did before if a is less than b to the D? That means that A over B to the D is less than 1.  So, you know that that sum converges and all you're left with is end-to-end to the D.  If a is equal to B to the D, then you have A over B to the D is equal to 1.  And so that some is linear in in with respect to the upper bound of the summation. Basically, you're just  Adding One log b-event many times. So that's why you get this one.  and then finally  He is greater than b to the D. Then you have A over B to the D is greater than 1 and you have that this summation kind of acts like an exponential and that's why you get this and you guys can use a exercise maybe to show that why those people  so that's where all of these things come from. You have the top-heavy the steady-state and the bottom heavy so you don't have to prove this every time just want to give you a sense of why it works. Okay. So now we can just use it without proof and your homework in the quiz, whatever you like.  Okay. Have a nice weekend everyone.  Can you see San Diego podcast? ",
  "Section": "a00",
  "Time": "1500",
  "Video URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-02082019-1500.mp4",
  "Audio URL": "http://podcast-media.ucsd.edu/Podcasts/wi19/cse101_a00_eoacc2krxy/cse101_a00-02082019-1500.mp3"
}